// Generated by PenPen 0.0.1.0 at 2013/11/16 23:58:37
/*
 * PenPen PEG Parser v0.0.1
 * http://github.com/kokudori/PenPen
 * 
 * Copyright (c) 2013 Kokudori <@Kokudori on Twitter>
 * Released under the MIT License
 * http://opensource.org/licenses/mit-license.php
 */

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;

using PenPen.Expressions;

// start
namespace PenPen
{
	class Parser
	{
		delegate State ParseFunc(State state, Stack<Result> results);
		string input;
		Dictionary<CacheKey, CacheValue> cache;
		Dictionary<string, ParseFunc> parsers;

		/// <summary>
		/// Parses based on the rules given the input string
		/// </summary>
		/// <param name="input">input string</param>
		/// <returns>result data</returns>
		internal Grammar Parse(string input)
		{
			var value = default(Grammar);
			var parsed = TryParse(input, out value);
			if (!parsed)
				throw new Exception("parse failed");
			return value;
		}

		/// <summary>
		/// Parses based on the rules given the input string
		/// </summary>
		/// <param name="input">input string</param>
		/// <param name="value">result data</param>
		/// <returns>success or failure in the parse</returns>
		internal bool TryParse(string input, out Grammar value)
		{
			this.input = input + "\0";
			var results = new Stack<Result>();
			cache = new Dictionary<CacheKey, CacheValue>();
			var result = Rule(new State(input, true, 0, 0), results, "grammar");
			var parsed = result.parsed && result.index == this.input.Length - 1;
			value = parsed ? results.Pop().value : default(Grammar);
			return parsed;
		}

		internal Parser()
		{
			#region Generated Rule Parsers

			parsers = new Dictionary<string, ParseFunc>()
			{
				// grammar = ___ prolog:prolog line epilog:epilog ___
				{ "grammar", (PenPenSpecifiedstate, PenPenSpecifiedresults) =>
					{
						var PenPenSpecifiedactionResults = new Stack<Result>();
						var PenPenSpecifiedresult = Sequence<string, IEnumerable<Config>, string, IEnumerable<Symbol>, string>(PenPenSpecifiedstate, PenPenSpecifiedactionResults, false,
							(s, r) => Rule(s, r, "___"),
							(s, r) => Label(s, r, "prolog",
								(ss, rr) => Rule(ss, rr, "prolog")),
							(s, r) => Rule(s, r, "line"),
							(s, r) => Label(s, r, "epilog",
								(ss, rr) => Rule(ss, rr, "epilog")),
							(s, r) => Rule(s, r, "___"));
						if (PenPenSpecifiedresult.parsed)
						{
							Func<IEnumerable<Config>, IEnumerable<Symbol>, Grammar> PenPenSpecifiedaction = (IEnumerable<Config> prolog, IEnumerable<Symbol> epilog) => {
								return new Grammar(prolog, epilog);
							};
							var PenPenSpecifiedvalue = (Grammar)PenPenSpecifiedaction(PenPenSpecifiedactionResults.Single(x => x.label == "prolog").value, PenPenSpecifiedactionResults.Single(x => x.label == "epilog").value);
							PenPenSpecifiedresults.Push(new Result(null, "Grammar", PenPenSpecifiedvalue));
						}
						return PenPenSpecifiedresult;
					}
				},
				// prolog = head:config tail:(line !symbol config)*
				{ "prolog", (PenPenSpecifiedstate, PenPenSpecifiedresults) =>
					{
						var PenPenSpecifiedactionResults = new Stack<Result>();
						var PenPenSpecifiedresult = Sequence<Config, IEnumerable<Tuple<string, Config>>>(PenPenSpecifiedstate, PenPenSpecifiedactionResults, false,
							(s, r) => Label(s, r, "head",
								(ss, rr) => Rule(ss, rr, "config")),
							(s, r) => Label(s, r, "tail",
								(ss, rr) => Repetition<Tuple<string, Config>>(ss, rr, 0, null,
									(sss, rrr) => Sequence<string, Config>(sss, rrr, true,
										(ssss, rrrr) => Rule(ssss, rrrr, "line"),
										(ssss, rrrr) => NegativeAssert(ssss, rrrr,
											(sssss, rrrrr) => Rule(sssss, rrrrr, "symbol")),
										(ssss, rrrr) => Rule(ssss, rrrr, "config")))));
						if (PenPenSpecifiedresult.parsed)
						{
							Func<Config, IEnumerable<Tuple<string, Config>>, IEnumerable<Config>> PenPenSpecifiedaction = (Config head, IEnumerable<Tuple<string, Config>> tail) => {
								return new[] { head }.Concat(tail.Select(x => x.Item2));
							};
							var PenPenSpecifiedvalue = (IEnumerable<Config>)PenPenSpecifiedaction(PenPenSpecifiedactionResults.Single(x => x.label == "head").value, PenPenSpecifiedactionResults.Single(x => x.label == "tail").value);
							PenPenSpecifiedresults.Push(new Result(null, "IEnumerable<Config>", PenPenSpecifiedvalue));
						}
						return PenPenSpecifiedresult;
					}
				},
				// epilog = head:symbol tail:(line symbol)+ / symbol
				{ "epilog", (PenPenSpecifiedstate, PenPenSpecifiedresults) =>
					{
						var PenPenSpecifiedactionResults = new Stack<Result>();
						var PenPenSpecifiedresult = Sequence<IEnumerable<Symbol>, IEnumerable<Tuple<string, IEnumerable<Symbol>>>>(PenPenSpecifiedstate, PenPenSpecifiedactionResults, false,
							(s, r) => Label(s, r, "head",
								(ss, rr) => Rule(ss, rr, "symbol")),
							(s, r) => Label(s, r, "tail",
								(ss, rr) => Repetition<Tuple<string, IEnumerable<Symbol>>>(ss, rr, 1, null,
									(sss, rrr) => Sequence<string, IEnumerable<Symbol>>(sss, rrr, true,
										(ssss, rrrr) => Rule(ssss, rrrr, "line"),
										(ssss, rrrr) => Rule(ssss, rrrr, "symbol")))));
						if (PenPenSpecifiedresult.parsed)
						{
							Func<IEnumerable<Symbol>, IEnumerable<Tuple<string, IEnumerable<Symbol>>>, IEnumerable<Symbol>> PenPenSpecifiedaction = (IEnumerable<Symbol> head, IEnumerable<Tuple<string, IEnumerable<Symbol>>> tail) => {
								return new[] { head }.Concat(tail.Select(x => x.Item2))
									.SelectMany(x => x as IEnumerable<Symbol>);
							};
							var PenPenSpecifiedvalue = (IEnumerable<Symbol>)PenPenSpecifiedaction(PenPenSpecifiedactionResults.Single(x => x.label == "head").value, PenPenSpecifiedactionResults.Single(x => x.label == "tail").value);
							PenPenSpecifiedresults.Push(new Result(null, "IEnumerable<Symbol>", PenPenSpecifiedvalue));
							return PenPenSpecifiedresult;
						}
						PenPenSpecifiedresult = Rule(PenPenSpecifiedstate, PenPenSpecifiedactionResults, "symbol");
						if (PenPenSpecifiedresult.parsed)
						{
							var PenPenSpecifiedvalue = PenPenSpecifiedactionResults.Pop().value;
							PenPenSpecifiedresults.Push(new Result(null, "IEnumerable<Symbol>", PenPenSpecifiedvalue));
							return PenPenSpecifiedresult;
						}
						return new State(input, false, PenPenSpecifiedstate.index, 0);
					}
				},
				// config = name:name __* ":" __* value:[^\r\n\t]+
				{ "config", (PenPenSpecifiedstate, PenPenSpecifiedresults) =>
					{
						var PenPenSpecifiedactionResults = new Stack<Result>();
						var PenPenSpecifiedresult = Sequence<string, IEnumerable<string>, char, IEnumerable<string>, string>(PenPenSpecifiedstate, PenPenSpecifiedactionResults, false,
							(s, r) => Label(s, r, "name",
								(ss, rr) => Rule(ss, rr, "name")),
							(s, r) => Repetition<string>(s, r, 0, null,
								(ss, rr) => Rule(ss, rr, "__")),
							(s, r) => Literal(s, r, "char", ":"),
							(s, r) => Repetition<string>(s, r, 0, null,
								(ss, rr) => Rule(ss, rr, "__")),
							(s, r) => Label(s, r, "value",
								(ss, rr) => Repetition<char>(ss, rr, 1, null,
									(sss, rrr) => Range(sss, rrr, true, "\r\n\t", "", null, "[^\r\n\t]"))));
						if (PenPenSpecifiedresult.parsed)
						{
							Func<string, string, Config> PenPenSpecifiedaction = (string name, string value) => {
								return new Config(name, value);
							};
							var PenPenSpecifiedvalue = (Config)PenPenSpecifiedaction(PenPenSpecifiedactionResults.Single(x => x.label == "name").value, PenPenSpecifiedactionResults.Single(x => x.label == "value").value);
							PenPenSpecifiedresults.Push(new Result(null, "Config", PenPenSpecifiedvalue));
						}
						return PenPenSpecifiedresult;
					}
				},
				// symbol = name:name type:type? display:display? _ "=" _ choice:choice
				{ "symbol", (PenPenSpecifiedstate, PenPenSpecifiedresults) =>
					{
						var PenPenSpecifiedactionResults = new Stack<Result>();
						var PenPenSpecifiedresult = Sequence<string, Maybe<string>, Maybe<string>, string, char, string, BaseExpression>(PenPenSpecifiedstate, PenPenSpecifiedactionResults, false,
							(s, r) => Label(s, r, "name",
								(ss, rr) => Rule(ss, rr, "name")),
							(s, r) => Label(s, r, "type",
								(ss, rr) => Optional<string>(ss, rr, "string",
									(sss, rrr) => Rule(sss, rrr, "type"))),
							(s, r) => Label(s, r, "display",
								(ss, rr) => Optional<string>(ss, rr, "string",
									(sss, rrr) => Rule(sss, rrr, "display"))),
							(s, r) => Rule(s, r, "_"),
							(s, r) => Literal(s, r, "char", "="),
							(s, r) => Rule(s, r, "_"),
							(s, r) => Label(s, r, "choice",
								(ss, rr) => Rule(ss, rr, "choice")));
						if (PenPenSpecifiedresult.parsed)
						{
							Func<string, Maybe<string>, Maybe<string>, BaseExpression, IEnumerable<Symbol>> PenPenSpecifiedaction = (string name, Maybe<string> type, Maybe<string> display, BaseExpression choice) => {
								var _type = type.Get("string");
								var _display = display.Get(name);
								if (choice is Choice)
									return (choice as Choice).Expressions.Select(x => new Symbol(name, _type, _display, x));
								return new[] { new Symbol(name, _type, _display, choice) };
							};
							var PenPenSpecifiedvalue = (IEnumerable<Symbol>)PenPenSpecifiedaction(PenPenSpecifiedactionResults.Single(x => x.label == "name").value, PenPenSpecifiedactionResults.Single(x => x.label == "type").value, PenPenSpecifiedactionResults.Single(x => x.label == "display").value, PenPenSpecifiedactionResults.Single(x => x.label == "choice").value);
							PenPenSpecifiedresults.Push(new Result(null, "IEnumerable<Symbol>", PenPenSpecifiedvalue));
						}
						return PenPenSpecifiedresult;
					}
				},
				// type = __* "::" __* name:[^\r\n \t]+
				{ "type", (PenPenSpecifiedstate, PenPenSpecifiedresults) =>
					{
						var PenPenSpecifiedactionResults = new Stack<Result>();
						var PenPenSpecifiedresult = Sequence<IEnumerable<string>, string, IEnumerable<string>, string>(PenPenSpecifiedstate, PenPenSpecifiedactionResults, false,
							(s, r) => Repetition<string>(s, r, 0, null,
								(ss, rr) => Rule(ss, rr, "__")),
							(s, r) => Literal(s, r, "string", "::"),
							(s, r) => Repetition<string>(s, r, 0, null,
								(ss, rr) => Rule(ss, rr, "__")),
							(s, r) => Label(s, r, "name",
								(ss, rr) => Repetition<char>(ss, rr, 1, null,
									(sss, rrr) => Range(sss, rrr, true, "\r\n \t", "", null, "[^\r\n \t]"))));
						if (PenPenSpecifiedresult.parsed)
						{
							Func<string, string> PenPenSpecifiedaction = (string name) => {
								return name;
							};
							var PenPenSpecifiedvalue = (string)PenPenSpecifiedaction(PenPenSpecifiedactionResults.Single(x => x.label == "name").value);
							PenPenSpecifiedresults.Push(new Result(null, "string", PenPenSpecifiedvalue));
						}
						return PenPenSpecifiedresult;
					}
				},
				// display = __ text:string
				{ "display", (PenPenSpecifiedstate, PenPenSpecifiedresults) =>
					{
						var PenPenSpecifiedactionResults = new Stack<Result>();
						var PenPenSpecifiedresult = Sequence<string, Literal>(PenPenSpecifiedstate, PenPenSpecifiedactionResults, false,
							(s, r) => Rule(s, r, "__"),
							(s, r) => Label(s, r, "text",
								(ss, rr) => Rule(ss, rr, "string")));
						if (PenPenSpecifiedresult.parsed)
						{
							Func<Literal, string> PenPenSpecifiedaction = (Literal text) => {
								return text.Value;
							};
							var PenPenSpecifiedvalue = (string)PenPenSpecifiedaction(PenPenSpecifiedactionResults.Single(x => x.label == "text").value);
							PenPenSpecifiedresults.Push(new Result(null, "string", PenPenSpecifiedvalue));
						}
						return PenPenSpecifiedresult;
					}
				},
				// label = name:name _* ":" _*
				{ "label", (PenPenSpecifiedstate, PenPenSpecifiedresults) =>
					{
						var PenPenSpecifiedactionResults = new Stack<Result>();
						var PenPenSpecifiedresult = Sequence<string, IEnumerable<string>, char, IEnumerable<string>>(PenPenSpecifiedstate, PenPenSpecifiedactionResults, false,
							(s, r) => Label(s, r, "name",
								(ss, rr) => Rule(ss, rr, "name")),
							(s, r) => Repetition<string>(s, r, 0, null,
								(ss, rr) => Rule(ss, rr, "_")),
							(s, r) => Literal(s, r, "char", ":"),
							(s, r) => Repetition<string>(s, r, 0, null,
								(ss, rr) => Rule(ss, rr, "_")));
						if (PenPenSpecifiedresult.parsed)
						{
							Func<string, string> PenPenSpecifiedaction = (string name) => {
								return name;
							};
							var PenPenSpecifiedvalue = (string)PenPenSpecifiedaction(PenPenSpecifiedactionResults.Single(x => x.label == "name").value);
							PenPenSpecifiedresults.Push(new Result(null, "string", PenPenSpecifiedvalue));
						}
						return PenPenSpecifiedresult;
					}
				},
				// choice = head:with_action tail:(_ "/" _ with_action)+ / with_action
				{ "choice", (PenPenSpecifiedstate, PenPenSpecifiedresults) =>
					{
						var PenPenSpecifiedactionResults = new Stack<Result>();
						var PenPenSpecifiedresult = Sequence<BaseExpression, IEnumerable<Tuple<string, char, string, BaseExpression>>>(PenPenSpecifiedstate, PenPenSpecifiedactionResults, false,
							(s, r) => Label(s, r, "head",
								(ss, rr) => Rule(ss, rr, "with_action")),
							(s, r) => Label(s, r, "tail",
								(ss, rr) => Repetition<Tuple<string, char, string, BaseExpression>>(ss, rr, 1, null,
									(sss, rrr) => Sequence<string, char, string, BaseExpression>(sss, rrr, true,
										(ssss, rrrr) => Rule(ssss, rrrr, "_"),
										(ssss, rrrr) => Literal(ssss, rrrr, "char", "/"),
										(ssss, rrrr) => Rule(ssss, rrrr, "_"),
										(ssss, rrrr) => Rule(ssss, rrrr, "with_action")))));
						if (PenPenSpecifiedresult.parsed)
						{
							Func<BaseExpression, IEnumerable<Tuple<string, char, string, BaseExpression>>, BaseExpression> PenPenSpecifiedaction = (BaseExpression head, IEnumerable<Tuple<string, char, string, BaseExpression>> tail) => {
								return new Choice(new[] { head }.Concat(tail.Select(x => x.Item4)));
							};
							var PenPenSpecifiedvalue = (BaseExpression)PenPenSpecifiedaction(PenPenSpecifiedactionResults.Single(x => x.label == "head").value, PenPenSpecifiedactionResults.Single(x => x.label == "tail").value);
							PenPenSpecifiedresults.Push(new Result(null, "BaseExpression", PenPenSpecifiedvalue));
							return PenPenSpecifiedresult;
						}
						PenPenSpecifiedresult = Rule(PenPenSpecifiedstate, PenPenSpecifiedactionResults, "with_action");
						if (PenPenSpecifiedresult.parsed)
						{
							var PenPenSpecifiedvalue = PenPenSpecifiedactionResults.Pop().value;
							PenPenSpecifiedresults.Push(new Result(null, "BaseExpression", PenPenSpecifiedvalue));
							return PenPenSpecifiedresult;
						}
						return new State(input, false, PenPenSpecifiedstate.index, 0);
					}
				},
				// with_action = sequence:sequence action:(_ action) / sequence
				{ "with_action", (PenPenSpecifiedstate, PenPenSpecifiedresults) =>
					{
						var PenPenSpecifiedactionResults = new Stack<Result>();
						var PenPenSpecifiedresult = Sequence<BaseExpression, Tuple<string, SemanticAction>>(PenPenSpecifiedstate, PenPenSpecifiedactionResults, false,
							(s, r) => Label(s, r, "sequence",
								(ss, rr) => Rule(ss, rr, "sequence")),
							(s, r) => Label(s, r, "action",
								(ss, rr) => Sequence<string, SemanticAction>(ss, rr, true,
									(sss, rrr) => Rule(sss, rrr, "_"),
									(sss, rrr) => Rule(sss, rrr, "action"))));
						if (PenPenSpecifiedresult.parsed)
						{
							Func<BaseExpression, Tuple<string, SemanticAction>, BaseExpression> PenPenSpecifiedaction = (BaseExpression sequence, Tuple<string, SemanticAction> action) => {
								sequence.Action = action.Item2;
								return sequence;
							};
							var PenPenSpecifiedvalue = (BaseExpression)PenPenSpecifiedaction(PenPenSpecifiedactionResults.Single(x => x.label == "sequence").value, PenPenSpecifiedactionResults.Single(x => x.label == "action").value);
							PenPenSpecifiedresults.Push(new Result(null, "BaseExpression", PenPenSpecifiedvalue));
							return PenPenSpecifiedresult;
						}
						PenPenSpecifiedresult = Rule(PenPenSpecifiedstate, PenPenSpecifiedactionResults, "sequence");
						if (PenPenSpecifiedresult.parsed)
						{
							var PenPenSpecifiedvalue = PenPenSpecifiedactionResults.Pop().value;
							PenPenSpecifiedresults.Push(new Result(null, "BaseExpression", PenPenSpecifiedvalue));
							return PenPenSpecifiedresult;
						}
						return new State(input, false, PenPenSpecifiedstate.index, 0);
					}
				},
				// sequence = head:assertion tail:(_ !symbol assertion)+ / assertion
				{ "sequence", (PenPenSpecifiedstate, PenPenSpecifiedresults) =>
					{
						var PenPenSpecifiedactionResults = new Stack<Result>();
						var PenPenSpecifiedresult = Sequence<BaseExpression, IEnumerable<Tuple<string, BaseExpression>>>(PenPenSpecifiedstate, PenPenSpecifiedactionResults, false,
							(s, r) => Label(s, r, "head",
								(ss, rr) => Rule(ss, rr, "assertion")),
							(s, r) => Label(s, r, "tail",
								(ss, rr) => Repetition<Tuple<string, BaseExpression>>(ss, rr, 1, null,
									(sss, rrr) => Sequence<string, BaseExpression>(sss, rrr, true,
										(ssss, rrrr) => Rule(ssss, rrrr, "_"),
										(ssss, rrrr) => NegativeAssert(ssss, rrrr,
											(sssss, rrrrr) => Rule(sssss, rrrrr, "symbol")),
										(ssss, rrrr) => Rule(ssss, rrrr, "assertion")))));
						if (PenPenSpecifiedresult.parsed)
						{
							Func<BaseExpression, IEnumerable<Tuple<string, BaseExpression>>, BaseExpression> PenPenSpecifiedaction = (BaseExpression head, IEnumerable<Tuple<string, BaseExpression>> tail) => {
								return new Sequence(new[] { head }.Concat(tail.Select(x => x.Item2)));
							};
							var PenPenSpecifiedvalue = (BaseExpression)PenPenSpecifiedaction(PenPenSpecifiedactionResults.Single(x => x.label == "head").value, PenPenSpecifiedactionResults.Single(x => x.label == "tail").value);
							PenPenSpecifiedresults.Push(new Result(null, "BaseExpression", PenPenSpecifiedvalue));
							return PenPenSpecifiedresult;
						}
						PenPenSpecifiedresult = Rule(PenPenSpecifiedstate, PenPenSpecifiedactionResults, "assertion");
						if (PenPenSpecifiedresult.parsed)
						{
							var PenPenSpecifiedvalue = PenPenSpecifiedactionResults.Pop().value;
							PenPenSpecifiedresults.Push(new Result(null, "BaseExpression", PenPenSpecifiedvalue));
							return PenPenSpecifiedresult;
						}
						return new State(input, false, PenPenSpecifiedstate.index, 0);
					}
				},
				// assertion = assert:("&" / "!") repetition:repetition / label:label repetition:repetition / repetition
				{ "assertion", (PenPenSpecifiedstate, PenPenSpecifiedresults) =>
					{
						var PenPenSpecifiedactionResults = new Stack<Result>();
						var PenPenSpecifiedresult = Sequence<char, BaseExpression>(PenPenSpecifiedstate, PenPenSpecifiedactionResults, false,
							(s, r) => Label(s, r, "assert",
								(ss, rr) => Choice(ss, rr, false,
									(sss, rrr) => Literal(sss, rrr, "char", "&"),
									(sss, rrr) => Literal(sss, rrr, "char", "!"))),
							(s, r) => Label(s, r, "repetition",
								(ss, rr) => Rule(ss, rr, "repetition")));
						if (PenPenSpecifiedresult.parsed)
						{
							Func<char, BaseExpression, BaseExpression> PenPenSpecifiedaction = (char assert, BaseExpression repetition) => {
								return new Assertion(assert == '&', repetition);
							};
							var PenPenSpecifiedvalue = (BaseExpression)PenPenSpecifiedaction(PenPenSpecifiedactionResults.Single(x => x.label == "assert").value, PenPenSpecifiedactionResults.Single(x => x.label == "repetition").value);
							PenPenSpecifiedresults.Push(new Result(null, "BaseExpression", PenPenSpecifiedvalue));
							return PenPenSpecifiedresult;
						}
						PenPenSpecifiedresult = Sequence<string, BaseExpression>(PenPenSpecifiedstate, PenPenSpecifiedactionResults, false,
							(s, r) => Label(s, r, "label",
								(ss, rr) => Rule(ss, rr, "label")),
							(s, r) => Label(s, r, "repetition",
								(ss, rr) => Rule(ss, rr, "repetition")));
						if (PenPenSpecifiedresult.parsed)
						{
							Func<string, BaseExpression, BaseExpression> PenPenSpecifiedaction = (string label, BaseExpression repetition) => {
								return new Labeled(label, repetition);
							};
							var PenPenSpecifiedvalue = (BaseExpression)PenPenSpecifiedaction(PenPenSpecifiedactionResults.Single(x => x.label == "label").value, PenPenSpecifiedactionResults.Single(x => x.label == "repetition").value);
							PenPenSpecifiedresults.Push(new Result(null, "BaseExpression", PenPenSpecifiedvalue));
							return PenPenSpecifiedresult;
						}
						PenPenSpecifiedresult = Rule(PenPenSpecifiedstate, PenPenSpecifiedactionResults, "repetition");
						if (PenPenSpecifiedresult.parsed)
						{
							var PenPenSpecifiedvalue = PenPenSpecifiedactionResults.Pop().value;
							PenPenSpecifiedresults.Push(new Result(null, "BaseExpression", PenPenSpecifiedvalue));
							return PenPenSpecifiedresult;
						}
						return new State(input, false, PenPenSpecifiedstate.index, 0);
					}
				},
				// repetition = primitive:primitive quantifier:("*" / "+") / primitive:primitive "?" / primitive
				{ "repetition", (PenPenSpecifiedstate, PenPenSpecifiedresults) =>
					{
						var PenPenSpecifiedactionResults = new Stack<Result>();
						var PenPenSpecifiedresult = Sequence<BaseExpression, char>(PenPenSpecifiedstate, PenPenSpecifiedactionResults, false,
							(s, r) => Label(s, r, "primitive",
								(ss, rr) => Rule(ss, rr, "primitive")),
							(s, r) => Label(s, r, "quantifier",
								(ss, rr) => Choice(ss, rr, false,
									(sss, rrr) => Literal(sss, rrr, "char", "*"),
									(sss, rrr) => Literal(sss, rrr, "char", "+"))));
						if (PenPenSpecifiedresult.parsed)
						{
							Func<BaseExpression, char, BaseExpression> PenPenSpecifiedaction = (BaseExpression primitive, char quantifier) => {
								var min = quantifier == '*' ? 0 : 1;
								return new Repetition(primitive, min, null);
							};
							var PenPenSpecifiedvalue = (BaseExpression)PenPenSpecifiedaction(PenPenSpecifiedactionResults.Single(x => x.label == "primitive").value, PenPenSpecifiedactionResults.Single(x => x.label == "quantifier").value);
							PenPenSpecifiedresults.Push(new Result(null, "BaseExpression", PenPenSpecifiedvalue));
							return PenPenSpecifiedresult;
						}
						PenPenSpecifiedresult = Sequence<BaseExpression, char>(PenPenSpecifiedstate, PenPenSpecifiedactionResults, false,
							(s, r) => Label(s, r, "primitive",
								(ss, rr) => Rule(ss, rr, "primitive")),
							(s, r) => Literal(s, r, "char", "?"));
						if (PenPenSpecifiedresult.parsed)
						{
							Func<BaseExpression, BaseExpression> PenPenSpecifiedaction = (BaseExpression primitive) => {
								return new Optional(primitive);
							};
							var PenPenSpecifiedvalue = (BaseExpression)PenPenSpecifiedaction(PenPenSpecifiedactionResults.Single(x => x.label == "primitive").value);
							PenPenSpecifiedresults.Push(new Result(null, "BaseExpression", PenPenSpecifiedvalue));
							return PenPenSpecifiedresult;
						}
						PenPenSpecifiedresult = Rule(PenPenSpecifiedstate, PenPenSpecifiedactionResults, "primitive");
						if (PenPenSpecifiedresult.parsed)
						{
							var PenPenSpecifiedvalue = PenPenSpecifiedactionResults.Pop().value;
							PenPenSpecifiedresults.Push(new Result(null, "BaseExpression", PenPenSpecifiedvalue));
							return PenPenSpecifiedresult;
						}
						return new State(input, false, PenPenSpecifiedstate.index, 0);
					}
				},
				// action = "{" code:code+ "}"
				{ "action", (PenPenSpecifiedstate, PenPenSpecifiedresults) =>
					{
						var PenPenSpecifiedactionResults = new Stack<Result>();
						var PenPenSpecifiedresult = Sequence<char, IEnumerable<string>, char>(PenPenSpecifiedstate, PenPenSpecifiedactionResults, false,
							(s, r) => Literal(s, r, "char", "{"),
							(s, r) => Label(s, r, "code",
								(ss, rr) => Repetition<string>(ss, rr, 1, null,
									(sss, rrr) => Rule(sss, rrr, "code"))),
							(s, r) => Literal(s, r, "char", "}"));
						if (PenPenSpecifiedresult.parsed)
						{
							Func<IEnumerable<string>, SemanticAction> PenPenSpecifiedaction = (IEnumerable<string> code) => {
								return new SemanticAction("{" + string.Join("", code) + "}");
							};
							var PenPenSpecifiedvalue = (SemanticAction)PenPenSpecifiedaction(PenPenSpecifiedactionResults.Single(x => x.label == "code").value);
							PenPenSpecifiedresults.Push(new Result(null, "SemanticAction", PenPenSpecifiedvalue));
						}
						return PenPenSpecifiedresult;
					}
				},
				// code = action:action / !"{" !"}" code:.
				{ "code", (PenPenSpecifiedstate, PenPenSpecifiedresults) =>
					{
						var PenPenSpecifiedactionResults = new Stack<Result>();
						var PenPenSpecifiedresult = Label(PenPenSpecifiedstate, PenPenSpecifiedactionResults, "action",
							(s, r) => Rule(s, r, "action"));
						if (PenPenSpecifiedresult.parsed)
						{
							Func<SemanticAction, string> PenPenSpecifiedaction = (SemanticAction action) => {
								return action.Code;
							};
							var PenPenSpecifiedvalue = (string)PenPenSpecifiedaction(PenPenSpecifiedactionResults.Single(x => x.label == "action").value);
							PenPenSpecifiedresults.Push(new Result(null, "string", PenPenSpecifiedvalue));
							return PenPenSpecifiedresult;
						}
						PenPenSpecifiedresult = Sequence<char>(PenPenSpecifiedstate, PenPenSpecifiedactionResults, false,
							(s, r) => NegativeAssert(s, r,
								(ss, rr) => Literal(ss, rr, "char", "{")),
							(s, r) => NegativeAssert(s, r,
								(ss, rr) => Literal(ss, rr, "char", "}")),
							(s, r) => Label(s, r, "code",
								(ss, rr) => Range(ss, rr, false, "", "\x0001\xFFFF", null, ".")));
						if (PenPenSpecifiedresult.parsed)
						{
							Func<char, string> PenPenSpecifiedaction = (char code) => {
								return code.ToString();
							};
							var PenPenSpecifiedvalue = (string)PenPenSpecifiedaction(PenPenSpecifiedactionResults.Single(x => x.label == "code").value);
							PenPenSpecifiedresults.Push(new Result(null, "string", PenPenSpecifiedvalue));
							return PenPenSpecifiedresult;
						}
						return new State(input, false, PenPenSpecifiedstate.index, 0);
					}
				},
				// primitive = char / string / range / any / rule / expression
				{ "primitive", (PenPenSpecifiedstate, PenPenSpecifiedresults) =>
					{
						var PenPenSpecifiedactionResults = new Stack<Result>();
						var PenPenSpecifiedresult = Rule(PenPenSpecifiedstate, PenPenSpecifiedactionResults, "char");
						if (PenPenSpecifiedresult.parsed)
						{
							var PenPenSpecifiedvalue = PenPenSpecifiedactionResults.Pop().value;
							PenPenSpecifiedresults.Push(new Result(null, "BaseExpression", PenPenSpecifiedvalue));
							return PenPenSpecifiedresult;
						}
						PenPenSpecifiedresult = Rule(PenPenSpecifiedstate, PenPenSpecifiedactionResults, "string");
						if (PenPenSpecifiedresult.parsed)
						{
							var PenPenSpecifiedvalue = PenPenSpecifiedactionResults.Pop().value;
							PenPenSpecifiedresults.Push(new Result(null, "BaseExpression", PenPenSpecifiedvalue));
							return PenPenSpecifiedresult;
						}
						PenPenSpecifiedresult = Rule(PenPenSpecifiedstate, PenPenSpecifiedactionResults, "range");
						if (PenPenSpecifiedresult.parsed)
						{
							var PenPenSpecifiedvalue = PenPenSpecifiedactionResults.Pop().value;
							PenPenSpecifiedresults.Push(new Result(null, "BaseExpression", PenPenSpecifiedvalue));
							return PenPenSpecifiedresult;
						}
						PenPenSpecifiedresult = Rule(PenPenSpecifiedstate, PenPenSpecifiedactionResults, "any");
						if (PenPenSpecifiedresult.parsed)
						{
							var PenPenSpecifiedvalue = PenPenSpecifiedactionResults.Pop().value;
							PenPenSpecifiedresults.Push(new Result(null, "BaseExpression", PenPenSpecifiedvalue));
							return PenPenSpecifiedresult;
						}
						PenPenSpecifiedresult = Rule(PenPenSpecifiedstate, PenPenSpecifiedactionResults, "rule");
						if (PenPenSpecifiedresult.parsed)
						{
							var PenPenSpecifiedvalue = PenPenSpecifiedactionResults.Pop().value;
							PenPenSpecifiedresults.Push(new Result(null, "BaseExpression", PenPenSpecifiedvalue));
							return PenPenSpecifiedresult;
						}
						PenPenSpecifiedresult = Rule(PenPenSpecifiedstate, PenPenSpecifiedactionResults, "expression");
						if (PenPenSpecifiedresult.parsed)
						{
							var PenPenSpecifiedvalue = PenPenSpecifiedactionResults.Pop().value;
							PenPenSpecifiedresults.Push(new Result(null, "BaseExpression", PenPenSpecifiedvalue));
							return PenPenSpecifiedresult;
						}
						return new State(input, false, PenPenSpecifiedstate.index, 0);
					}
				},
				// char = "'" content:(escape / [^']) "'"
				{ "char", (PenPenSpecifiedstate, PenPenSpecifiedresults) =>
					{
						var PenPenSpecifiedactionResults = new Stack<Result>();
						var PenPenSpecifiedresult = Sequence<string, string, string>(PenPenSpecifiedstate, PenPenSpecifiedactionResults, false,
							(s, r) => Literal(s, r, "string", "'"),
							(s, r) => Label(s, r, "content",
								(ss, rr) => Choice(ss, rr, true,
									(sss, rrr) => Rule(sss, rrr, "escape"),
									(sss, rrr) => Range(sss, rrr, true, "'", "", null, "[^']"))),
							(s, r) => Literal(s, r, "string", "'"));
						if (PenPenSpecifiedresult.parsed)
						{
							Func<string, Literal> PenPenSpecifiedaction = (string content) => {
								return new Literal(content, true);
							};
							var PenPenSpecifiedvalue = (Literal)PenPenSpecifiedaction(PenPenSpecifiedactionResults.Single(x => x.label == "content").value);
							PenPenSpecifiedresults.Push(new Result(null, "Literal", PenPenSpecifiedvalue));
						}
						return PenPenSpecifiedresult;
					}
				},
				// string = "\"" content:("\\\"" / "\x5c\x5c" / [^\"])+ "\""
				{ "string", (PenPenSpecifiedstate, PenPenSpecifiedresults) =>
					{
						var PenPenSpecifiedactionResults = new Stack<Result>();
						var PenPenSpecifiedresult = Sequence<char, IEnumerable<string>, char>(PenPenSpecifiedstate, PenPenSpecifiedactionResults, false,
							(s, r) => Literal(s, r, "char", "\""),
							(s, r) => Label(s, r, "content",
								(ss, rr) => Repetition<string>(ss, rr, 1, null,
									(sss, rrr) => Choice(sss, rrr, true,
										(ssss, rrrr) => Literal(ssss, rrrr, "string", "\\\""),
										(ssss, rrrr) => Literal(ssss, rrrr, "string", "\x5c\x5c"),
										(ssss, rrrr) => Range(ssss, rrrr, true, "\"", "", null, "[^\"]")))),
							(s, r) => Literal(s, r, "char", "\""));
						if (PenPenSpecifiedresult.parsed)
						{
							Func<IEnumerable<string>, Literal> PenPenSpecifiedaction = (IEnumerable<string> content) => {
								return new Literal(string.Join("", content), false);
							};
							var PenPenSpecifiedvalue = (Literal)PenPenSpecifiedaction(PenPenSpecifiedactionResults.Single(x => x.label == "content").value);
							PenPenSpecifiedresults.Push(new Result(null, "Literal", PenPenSpecifiedvalue));
						}
						return PenPenSpecifiedresult;
					}
				},
				// escape = "\\" ("n" / "r" / "t" / "\'" / "\"" / "\\" / "0" / "a" / "b" / "f")
				{ "escape", (PenPenSpecifiedstate, PenPenSpecifiedresults) =>
					{
						var PenPenSpecifiedactionResults = new Stack<Result>();
						var PenPenSpecifiedresult = Sequence<char, char>(PenPenSpecifiedstate, PenPenSpecifiedactionResults, false,
							(s, r) => Literal(s, r, "char", "\\"),
							(s, r) => Choice(s, r, false,
								(ss, rr) => Literal(ss, rr, "char", "n"),
								(ss, rr) => Literal(ss, rr, "char", "r"),
								(ss, rr) => Literal(ss, rr, "char", "t"),
								(ss, rr) => Literal(ss, rr, "char", "\'"),
								(ss, rr) => Literal(ss, rr, "char", "\""),
								(ss, rr) => Literal(ss, rr, "char", "\\"),
								(ss, rr) => Literal(ss, rr, "char", "0"),
								(ss, rr) => Literal(ss, rr, "char", "a"),
								(ss, rr) => Literal(ss, rr, "char", "b"),
								(ss, rr) => Literal(ss, rr, "char", "f")));
						if (PenPenSpecifiedresult.parsed)
						{
							var PenPenSpecifiedvalue = input.Substring(PenPenSpecifiedstate.index, PenPenSpecifiedresult.index - PenPenSpecifiedstate.index);
							PenPenSpecifiedresults.Push(new Result(null, "string", PenPenSpecifiedvalue));
						}
						return PenPenSpecifiedresult;
					}
				},
				// any = "."
				{ "any", (PenPenSpecifiedstate, PenPenSpecifiedresults) =>
					{
						var PenPenSpecifiedactionResults = new Stack<Result>();
						var PenPenSpecifiedresult = Literal(PenPenSpecifiedstate, PenPenSpecifiedactionResults, "char", ".");
						if (PenPenSpecifiedresult.parsed)
						{
							Func<Range> PenPenSpecifiedaction = () => {
								return new Range("\x0001-\xFFFF");
							};
							var PenPenSpecifiedvalue = (Range)PenPenSpecifiedaction();
							PenPenSpecifiedresults.Push(new Result(null, "Range", PenPenSpecifiedvalue));
						}
						return PenPenSpecifiedresult;
					}
				},
				// range = "[" content:("\\]" / "\\\\" / [^\\]])+ "]"
				{ "range", (PenPenSpecifiedstate, PenPenSpecifiedresults) =>
					{
						var PenPenSpecifiedactionResults = new Stack<Result>();
						var PenPenSpecifiedresult = Sequence<char, IEnumerable<string>, char>(PenPenSpecifiedstate, PenPenSpecifiedactionResults, false,
							(s, r) => Literal(s, r, "char", "["),
							(s, r) => Label(s, r, "content",
								(ss, rr) => Repetition<string>(ss, rr, 1, null,
									(sss, rrr) => Choice(sss, rrr, true,
										(ssss, rrrr) => Literal(ssss, rrrr, "string", "\\]"),
										(ssss, rrrr) => Literal(ssss, rrrr, "string", "\\\\"),
										(ssss, rrrr) => Range(ssss, rrrr, true, "]", "", null, "[^\\]]")))),
							(s, r) => Literal(s, r, "char", "]"));
						if (PenPenSpecifiedresult.parsed)
						{
							Func<IEnumerable<string>, Range> PenPenSpecifiedaction = (IEnumerable<string> content) => {
								return new Range(string.Join("", content));
							};
							var PenPenSpecifiedvalue = (Range)PenPenSpecifiedaction(PenPenSpecifiedactionResults.Single(x => x.label == "content").value);
							PenPenSpecifiedresults.Push(new Result(null, "Range", PenPenSpecifiedvalue));
						}
						return PenPenSpecifiedresult;
					}
				},
				// expression = "(" _* choice:choice _* ")"
				{ "expression", (PenPenSpecifiedstate, PenPenSpecifiedresults) =>
					{
						var PenPenSpecifiedactionResults = new Stack<Result>();
						var PenPenSpecifiedresult = Sequence<char, IEnumerable<string>, BaseExpression, IEnumerable<string>, char>(PenPenSpecifiedstate, PenPenSpecifiedactionResults, false,
							(s, r) => Literal(s, r, "char", "("),
							(s, r) => Repetition<string>(s, r, 0, null,
								(ss, rr) => Rule(ss, rr, "_")),
							(s, r) => Label(s, r, "choice",
								(ss, rr) => Rule(ss, rr, "choice")),
							(s, r) => Repetition<string>(s, r, 0, null,
								(ss, rr) => Rule(ss, rr, "_")),
							(s, r) => Literal(s, r, "char", ")"));
						if (PenPenSpecifiedresult.parsed)
						{
							Func<BaseExpression, Expression> PenPenSpecifiedaction = (BaseExpression choice) => {
								return new Expression(choice);
							};
							var PenPenSpecifiedvalue = (Expression)PenPenSpecifiedaction(PenPenSpecifiedactionResults.Single(x => x.label == "choice").value);
							PenPenSpecifiedresults.Push(new Result(null, "Expression", PenPenSpecifiedvalue));
						}
						return PenPenSpecifiedresult;
					}
				},
				// name = head:[_a-zA-Z] tail:[_a-zA-Z0-9]*
				{ "name", (PenPenSpecifiedstate, PenPenSpecifiedresults) =>
					{
						var PenPenSpecifiedactionResults = new Stack<Result>();
						var PenPenSpecifiedresult = Sequence<char, string>(PenPenSpecifiedstate, PenPenSpecifiedactionResults, false,
							(s, r) => Label(s, r, "head",
								(ss, rr) => Range(ss, rr, false, "_", "azAZ", null, "[_a-zA-Z]")),
							(s, r) => Label(s, r, "tail",
								(ss, rr) => Repetition<char>(ss, rr, 0, null,
									(sss, rrr) => Range(sss, rrr, false, "_", "azAZ09", null, "[_a-zA-Z0-9]"))));
						if (PenPenSpecifiedresult.parsed)
						{
							Func<char, string, string> PenPenSpecifiedaction = (char head, string tail) => {
								return head + tail;
							};
							var PenPenSpecifiedvalue = (string)PenPenSpecifiedaction(PenPenSpecifiedactionResults.Single(x => x.label == "head").value, PenPenSpecifiedactionResults.Single(x => x.label == "tail").value);
							PenPenSpecifiedresults.Push(new Result(null, "string", PenPenSpecifiedvalue));
						}
						return PenPenSpecifiedresult;
					}
				},
				// rule = name:name
				{ "rule", (PenPenSpecifiedstate, PenPenSpecifiedresults) =>
					{
						var PenPenSpecifiedactionResults = new Stack<Result>();
						var PenPenSpecifiedresult = Label(PenPenSpecifiedstate, PenPenSpecifiedactionResults, "name",
							(s, r) => Rule(s, r, "name"));
						if (PenPenSpecifiedresult.parsed)
						{
							Func<string, Rule> PenPenSpecifiedaction = (string name) => {
								return new Rule(name);
							};
							var PenPenSpecifiedvalue = (Rule)PenPenSpecifiedaction(PenPenSpecifiedactionResults.Single(x => x.label == "name").value);
							PenPenSpecifiedresults.Push(new Result(null, "Rule", PenPenSpecifiedvalue));
						}
						return PenPenSpecifiedresult;
					}
				},
				// space = [ \t]
				{ "space", (PenPenSpecifiedstate, PenPenSpecifiedresults) =>
					{
						var PenPenSpecifiedactionResults = new Stack<Result>();
						var PenPenSpecifiedresult = Range(PenPenSpecifiedstate, PenPenSpecifiedactionResults, false, " \t", "", null, "[ \t]");
						if (PenPenSpecifiedresult.parsed)
						{
							var PenPenSpecifiedvalue = input.Substring(PenPenSpecifiedstate.index, PenPenSpecifiedresult.index - PenPenSpecifiedstate.index);
							PenPenSpecifiedresults.Push(new Result(null, "string", PenPenSpecifiedvalue));
						}
						return PenPenSpecifiedresult;
					}
				},
				// newline = "\r\n" / "\r" / "\n"
				{ "newline", (PenPenSpecifiedstate, PenPenSpecifiedresults) =>
					{
						var PenPenSpecifiedactionResults = new Stack<Result>();
						var PenPenSpecifiedresult = Literal(PenPenSpecifiedstate, PenPenSpecifiedactionResults, "string", "\r\n");
						if (PenPenSpecifiedresult.parsed)
						{
							var PenPenSpecifiedvalue = input.Substring(PenPenSpecifiedstate.index, PenPenSpecifiedresult.index - PenPenSpecifiedstate.index);
							PenPenSpecifiedresults.Push(new Result(null, "string", PenPenSpecifiedvalue));
							return PenPenSpecifiedresult;
						}
						PenPenSpecifiedresult = Literal(PenPenSpecifiedstate, PenPenSpecifiedactionResults, "string", "\r");
						if (PenPenSpecifiedresult.parsed)
						{
							var PenPenSpecifiedvalue = input.Substring(PenPenSpecifiedstate.index, PenPenSpecifiedresult.index - PenPenSpecifiedstate.index);
							PenPenSpecifiedresults.Push(new Result(null, "string", PenPenSpecifiedvalue));
							return PenPenSpecifiedresult;
						}
						PenPenSpecifiedresult = Literal(PenPenSpecifiedstate, PenPenSpecifiedactionResults, "string", "\n");
						if (PenPenSpecifiedresult.parsed)
						{
							var PenPenSpecifiedvalue = input.Substring(PenPenSpecifiedstate.index, PenPenSpecifiedresult.index - PenPenSpecifiedstate.index);
							PenPenSpecifiedresults.Push(new Result(null, "string", PenPenSpecifiedvalue));
							return PenPenSpecifiedresult;
						}
						return new State(input, false, PenPenSpecifiedstate.index, 0);
					}
				},
				// comment = "#" [^\r\n]* newline
				{ "comment", (PenPenSpecifiedstate, PenPenSpecifiedresults) =>
					{
						var PenPenSpecifiedactionResults = new Stack<Result>();
						var PenPenSpecifiedresult = Sequence<char, string, string>(PenPenSpecifiedstate, PenPenSpecifiedactionResults, false,
							(s, r) => Literal(s, r, "char", "#"),
							(s, r) => Repetition<char>(s, r, 0, null,
								(ss, rr) => Range(ss, rr, true, "\r\n", "", null, "[^\r\n]")),
							(s, r) => Rule(s, r, "newline"));
						if (PenPenSpecifiedresult.parsed)
						{
							var PenPenSpecifiedvalue = input.Substring(PenPenSpecifiedstate.index, PenPenSpecifiedresult.index - PenPenSpecifiedstate.index);
							PenPenSpecifiedresults.Push(new Result(null, "string", PenPenSpecifiedvalue));
						}
						return PenPenSpecifiedresult;
					}
				},
				// _ = (space / newline)+ comment? (space / newline)*
				{ "_", (PenPenSpecifiedstate, PenPenSpecifiedresults) =>
					{
						var PenPenSpecifiedactionResults = new Stack<Result>();
						var PenPenSpecifiedresult = Sequence<IEnumerable<string>, Maybe<string>, IEnumerable<string>>(PenPenSpecifiedstate, PenPenSpecifiedactionResults, false,
							(s, r) => Repetition<string>(s, r, 1, null,
								(ss, rr) => Choice(ss, rr, false,
									(sss, rrr) => Rule(sss, rrr, "space"),
									(sss, rrr) => Rule(sss, rrr, "newline"))),
							(s, r) => Optional<string>(s, r, "string",
								(ss, rr) => Rule(ss, rr, "comment")),
							(s, r) => Repetition<string>(s, r, 0, null,
								(ss, rr) => Choice(ss, rr, false,
									(sss, rrr) => Rule(sss, rrr, "space"),
									(sss, rrr) => Rule(sss, rrr, "newline"))));
						if (PenPenSpecifiedresult.parsed)
						{
							var PenPenSpecifiedvalue = input.Substring(PenPenSpecifiedstate.index, PenPenSpecifiedresult.index - PenPenSpecifiedstate.index);
							PenPenSpecifiedresults.Push(new Result(null, "string", PenPenSpecifiedvalue));
						}
						return PenPenSpecifiedresult;
					}
				},
				// __ = space+
				{ "__", (PenPenSpecifiedstate, PenPenSpecifiedresults) =>
					{
						var PenPenSpecifiedactionResults = new Stack<Result>();
						var PenPenSpecifiedresult = Repetition<string>(PenPenSpecifiedstate, PenPenSpecifiedactionResults, 1, null,
							(s, r) => Rule(s, r, "space"));
						if (PenPenSpecifiedresult.parsed)
						{
							var PenPenSpecifiedvalue = input.Substring(PenPenSpecifiedstate.index, PenPenSpecifiedresult.index - PenPenSpecifiedstate.index);
							PenPenSpecifiedresults.Push(new Result(null, "string", PenPenSpecifiedvalue));
						}
						return PenPenSpecifiedresult;
					}
				},
				// line = space* (comment / newline)+ (space / newline)*
				{ "line", (PenPenSpecifiedstate, PenPenSpecifiedresults) =>
					{
						var PenPenSpecifiedactionResults = new Stack<Result>();
						var PenPenSpecifiedresult = Sequence<IEnumerable<string>, IEnumerable<string>, IEnumerable<string>>(PenPenSpecifiedstate, PenPenSpecifiedactionResults, false,
							(s, r) => Repetition<string>(s, r, 0, null,
								(ss, rr) => Rule(ss, rr, "space")),
							(s, r) => Repetition<string>(s, r, 1, null,
								(ss, rr) => Choice(ss, rr, false,
									(sss, rrr) => Rule(sss, rrr, "comment"),
									(sss, rrr) => Rule(sss, rrr, "newline"))),
							(s, r) => Repetition<string>(s, r, 0, null,
								(ss, rr) => Choice(ss, rr, false,
									(sss, rrr) => Rule(sss, rrr, "space"),
									(sss, rrr) => Rule(sss, rrr, "newline"))));
						if (PenPenSpecifiedresult.parsed)
						{
							var PenPenSpecifiedvalue = input.Substring(PenPenSpecifiedstate.index, PenPenSpecifiedresult.index - PenPenSpecifiedstate.index);
							PenPenSpecifiedresults.Push(new Result(null, "string", PenPenSpecifiedvalue));
						}
						return PenPenSpecifiedresult;
					}
				},
				// ___ = (space / newline)* comment? (space / newline)*
				{ "___", (PenPenSpecifiedstate, PenPenSpecifiedresults) =>
					{
						var PenPenSpecifiedactionResults = new Stack<Result>();
						var PenPenSpecifiedresult = Sequence<IEnumerable<string>, Maybe<string>, IEnumerable<string>>(PenPenSpecifiedstate, PenPenSpecifiedactionResults, false,
							(s, r) => Repetition<string>(s, r, 0, null,
								(ss, rr) => Choice(ss, rr, false,
									(sss, rrr) => Rule(sss, rrr, "space"),
									(sss, rrr) => Rule(sss, rrr, "newline"))),
							(s, r) => Optional<string>(s, r, "string",
								(ss, rr) => Rule(ss, rr, "comment")),
							(s, r) => Repetition<string>(s, r, 0, null,
								(ss, rr) => Choice(ss, rr, false,
									(sss, rrr) => Rule(sss, rrr, "space"),
									(sss, rrr) => Rule(sss, rrr, "newline"))));
						if (PenPenSpecifiedresult.parsed)
						{
							var PenPenSpecifiedvalue = input.Substring(PenPenSpecifiedstate.index, PenPenSpecifiedresult.index - PenPenSpecifiedstate.index);
							PenPenSpecifiedresults.Push(new Result(null, "string", PenPenSpecifiedvalue));
						}
						return PenPenSpecifiedresult;
					}
				}
			};

			#endregion
		}

		#region Built-in Parsers

		State Rule(State state, Stack<Result> results, string rule)
		{
			var key = new CacheKey(rule, state.index);
			CacheValue value;
			if (cache.TryGetValue(key, out value))
			{
				if (value.state.parsed)
					results.Push(value.result);
				return value.state;
			}
			else
			{
				var result = parsers[rule](state, results);
				cache.Add(key, new CacheValue(result, result.parsed ? results.Peek() : null));
				return result;
			}
		}

		State Choice(State state, Stack<Result> results, bool isImplicit, params ParseFunc[] parses)
		{
			var start = state.index;
			foreach (var parse in parses)
			{
				var result = parse(state, results);
				if (result.parsed)
				{
					if (isImplicit)
					{
						var value = results.Pop();
						if (value.type == "char" && value.value is char)
							results.Push(new Result(value.label, "string", value.value.ToString()));
						else
							results.Push(value);
					}
					return result;
				}
				state = new State(input, false, start, 0);
			}
			return state;
		}

		State Sequence(State state, Stack<Result> results, params ParseFunc[] parses)
		{
			var start = state.index;
			var stack = new Stack<Result>();
			foreach (var parse in parses)
			{
				state = parse(state, results);
				if (!state.parsed)
					return new State(input, false, start, 0);
				var result = results.Pop();
				if (!(result is Assert))
					stack.Push(result);
			}
			foreach (var result in stack)
			{
				results.Push(result);
			}
			return new State(input, true, state.index, state.index - start);
		}

		State Sequence<T>(State state, Stack<Result> results, bool inner, params ParseFunc[] parses)
		{
			var result = Sequence(state, results, parses);
			if (!result.parsed)
				return new State(input, false, state.index, 0);
			if (inner)
			{
				var types = string.Format("{0}", typeof(T).Name);
				var value = results.Pop().value;
				results.Push(new Result(null, types, value));
			}
			return result;
		}

		State Sequence<T1, T2>(State state, Stack<Result> results, bool inner, params ParseFunc[] parses)
		{
			var result = Sequence(state, results, parses);
			if (!result.parsed)
				return new State(input, false, state.index, 0);
			if (inner)
			{
				var types = string.Format("Tuple<{0}, {1}>", typeof(T1).Name, typeof(T2).Name);
				var value = new Tuple<T1, T2>(results.Pop().value, results.Pop().value);
				results.Push(new Result(null, types, value));
			}
			return result;
		}

		State Sequence<T1, T2, T3>(State state, Stack<Result> results, bool inner, params ParseFunc[] parses)
		{
			var result = Sequence(state, results, parses);
			if (!result.parsed)
				return new State(input, false, state.index, 0);
			if (inner)
			{
				var types = string.Format("Tuple<{0}, {1}, {2}>", typeof(T1).Name, typeof(T2).Name, typeof(T3).Name);
				var value = new Tuple<T1, T2, T3>(results.Pop().value, results.Pop().value, results.Pop().value);
				results.Push(new Result(null, types, value));
			}
			return result;
		}

		State Sequence<T1, T2, T3, T4>(State state, Stack<Result> results, bool inner, params ParseFunc[] parses)
		{
			var result = Sequence(state, results, parses);
			if (!result.parsed)
				return new State(input, false, state.index, 0);
			if (inner)
			{
				var types = string.Format("Tuple<{0}, {1}, {2}, {3}>", typeof(T1).Name, typeof(T2).Name, typeof(T3).Name, typeof(T4).Name);
				var value = new Tuple<T1, T2, T3, T4>(results.Pop().value, results.Pop().value, results.Pop().value, results.Pop().value);
				results.Push(new Result(null, types, value));
			}
			return result;
		}

		State Sequence<T1, T2, T3, T4, T5>(State state, Stack<Result> results, bool inner, params ParseFunc[] parses)
		{
			var result = Sequence(state, results, parses);
			if (!result.parsed)
				return new State(input, false, state.index, 0);
			if (inner)
			{
				var types = string.Format("Tuple<{0}, {1}, {2}, {3}, {4}>", typeof(T1).Name, typeof(T2).Name, typeof(T3).Name, typeof(T4).Name, typeof(T5));
				var value = new Tuple<T1, T2, T3, T4, T5>(results.Pop().value, results.Pop().value, results.Pop().value, results.Pop().value, results.Pop().value);
				results.Push(new Result(null, types, value));
			}
			return result;
		}

		State Sequence<T1, T2, T3, T4, T5, T6>(State state, Stack<Result> results, bool inner, params ParseFunc[] parses)
		{
			var result = Sequence(state, results, parses);
			if (!result.parsed)
				return new State(input, false, state.index, 0);
			if (inner)
			{
				var types = string.Format("Tuple<{0}, {1}, {2}, {3}, {4}, {5}>", typeof(T1).Name, typeof(T2).Name, typeof(T3).Name, typeof(T4).Name, typeof(T5), typeof(T6));
				var value = new Tuple<T1, T2, T3, T4, T5, T6>(results.Pop().value, results.Pop().value, results.Pop().value, results.Pop().value, results.Pop().value, results.Pop().value);
				results.Push(new Result(null, types, value));
			}
			return result;
		}

		State Sequence<T1, T2, T3, T4, T5, T6, T7>(State state, Stack<Result> results, bool inner, params ParseFunc[] parses)
		{
			var result = Sequence(state, results, parses);
			if (!result.parsed)
				return new State(input, false, state.index, 0);
			if (inner)
			{
				var types = string.Format("Tuple<{0}, {1}, {2}, {3}, {4}, {5}, {6}>", typeof(T1).Name, typeof(T2).Name, typeof(T3).Name, typeof(T4).Name, typeof(T5), typeof(T6).Name, typeof(T7));
				var value = new Tuple<T1, T2, T3, T4, T5, T6, T7>(results.Pop().value, results.Pop().value, results.Pop().value, results.Pop().value, results.Pop().value, results.Pop().value, results.Pop().value);
				results.Push(new Result(null, types, value));
			}
			return result;
		}

		State Literal(State state, Stack<Result> results, string type, string literal)
		{
			if (literal.Length > input.Skip(state.index).Count())
				return new State(input, false, state.index, 0);
			var text = input.Substring(state.index, literal.Length);
			if (text != literal)
				return new State(input, false, state.index, 0);

			if (type == "string")
				results.Push(new Result(null, type, text));
			else if (type == "char")
				results.Push(new Result(null, type, text.Single()));
			return new State(input, true, state.index + literal.Length, literal.Length);
		}

		State Optional<T>(State state, Stack<Result> results, string type, ParseFunc parse)
		{
			var count = results.Count;
			var result = parse(state, results);
			var index = result.parsed ? result.index : state.index;
			var length = result.parsed ? result.index - state.index : 0;
			var value = result.parsed ? Maybe<T>.Just(results.Pop().value) : Maybe<T>.Nothing();

			results.Push(new Result(null, type, value));
			return new State(input, true, index, length);
		}

		State Repetition<T>(State state, Stack<Result> results, int min, int? max, ParseFunc parse)
		{
			var list = new List<T>();

			var start = state;
			max = max ?? int.MaxValue;
			var count = 0;
			while (count <= max)
			{
				var result = parse(state, results);
				if (result.parsed && result.index > state.index)
				{
					state = result;
					list.Add(results.Pop().value);
					count++;
				}
				else
				{
					state = new State(input, true, state.index, state.index - start.index);
					break;
				}
			}
			if (count < min || count > max)
				return new State(input, false, start.index, 0);

			if (typeof(T).Name == "Char")
				results.Push(new Result(null, "string", string.Join("", list.Select(x => x.ToString()))));
			else
				results.Push(new Result(null, "IEnumerable<" + typeof(T).Name + ">", list));
			return state;
		}

		State Range(State state, Stack<Result> results, bool inverted, string chars, string ranges, UnicodeCategory[] categories, string label)
		{
			var ch = input[state.index];
			var matched = chars.IndexOf(ch) >= 0;

			for (int i = 0; i < ranges.Length && !matched; i += 2)
			{
				matched = ranges[i] <= ch && ch <= ranges[i + 1];
			}
			for (int i = 0; categories != null && i < categories.Length && !matched; ++i)
			{
				matched = char.GetUnicodeCategory(ch) == categories[i];
			}

			if (inverted)
				matched = !matched && ch != '\x0';

			if (matched)
			{
				results.Push(new Result(null, "char", input.Substring(state.index, 1).Single()));
				return new State(input, true, state.index + 1, 1);
			}

			return new State(input, false, state.index, 0);
		}

		State PositiveAssert(State state, Stack<Result> results, ParseFunc parse)
		{
			var result = parse(state, results);
			if (result.parsed)
				results.Push(new Assert(results.Pop()));
			return new State(input, result.parsed, state.index, 0);
		}

		State NegativeAssert(State state, Stack<Result> results, ParseFunc parse)
		{
			var result = parse(state, results);
			if (result.parsed)
				results.Pop();
			else
				results.Push(new Assert(new Result(null, null, null)));
			return new State(input, !result.parsed, state.index, 0);
		}

		State Label(State state, Stack<Result> results, string label, ParseFunc parse)
		{
			var result = parse(state, results);
			if (!result.parsed)
				return new State(input, false, state.index, 0);

			var value = results.Pop();
			results.Push(new Result(label, value.type, value.value));
			return result;
		}

		#endregion

		#region Internal Informations

		private sealed class State
		{
			internal readonly string input;
			internal readonly bool parsed;
			internal readonly int index;
			internal readonly int length;

			internal State(string input, bool parsed, int index, int length)
			{
				this.input = input;
				this.parsed = parsed;
				this.index = index;
				this.length = length;
			}

			int line()
			{
				var line = 1;
				var i = 0;
				while (i <= index)
				{
					var ch = input[i++];
					if (ch == '\r' && input[i] == '\n')
					{
						++i;
						++line;
					}
					else if (ch == '\r' || ch == '\n')
					{
						++line;
					}
				}
				return line;
			}

			int colum()
			{
				var i = index;
				while (i > 0 && input[i - 1] != '\n' && input[i - 1] != '\r')
				{
					--i;
				}
				return index - i + 1;
			}

			public override string ToString()
			{
				var successed = parsed ? "success" : "failed";
				return string.Format("{0}: {1}Line, {2}Colum", successed, line(), colum());
			}
		}

		private class Result
		{
			internal readonly string label;
			internal readonly string type;
			internal readonly dynamic value;

			internal Result(string label, string type, dynamic value)
			{
				this.label = label;
				this.type = type;
				this.value = value;
			}
		}

		private sealed class Assert : Result
		{
			public Assert(Result result)
				: base(result.label, result.type, result.value as object)
			{

			}
		}

		private struct CacheKey : IEquatable<CacheKey>
		{
			string rule;
			int index;

			internal CacheKey(string rule, int index)
			{
				this.rule = rule;
				this.index = index;
			}

			public bool Equals(CacheKey other)
			{
				if (this.rule != other.rule)
					return false;
				if (this.index != other.index)
					return false;
				return true;
			}

			public static bool operator ==(CacheKey left, CacheKey right)
			{
				return left.Equals(right);
			}

			public static bool operator !=(CacheKey left, CacheKey right)
			{
				return !(left == right);
			}

			public override bool Equals(object obj)
			{
				if (obj == null)
					return false;
				if (GetType() != obj.GetType())
					return false;
				return this == (CacheKey)obj;
			}

			public override int GetHashCode()
			{
				var hash = 0;
				unchecked
				{
					hash += rule.GetHashCode();
					hash += index.GetHashCode();
				}
				return hash;
			}
		}

		private struct CacheValue
		{
			internal readonly State state;
			internal readonly Result result;

			internal CacheValue(State state, Result result)
			{
				this.state = state;
				this.result = result;
			}
		}

		#endregion

		#region Utilities

		class Maybe<T>
		{
			readonly T value;

			internal readonly bool isJust;
			internal readonly bool isNothing;

			Maybe(T value, bool isJust)
			{
				this.value = value;
				this.isJust = isJust;
				isNothing = !isJust;
			}

			internal T Get()
			{
				if (isNothing)
					throw new Exception("nothing");
				return value;
			}

			internal T Get(T other)
			{
				return isJust ? value : other;
			}

			internal static Maybe<T> Just(T value)
			{
				return new Maybe<T>(value, true);
			}

			internal static Maybe<T> Nothing()
			{
				return new Maybe<T>(default(T), false);
			}
		}

		#endregion
	}
// end
}
